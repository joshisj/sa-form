"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var get_1 = tslib_1.__importDefault(require("lodash/get"));
var mapValues_1 = tslib_1.__importDefault(require("lodash/mapValues"));
var react_1 = require("react");
var joinName_1 = tslib_1.__importDefault(require("./joinName"));
var useForm_1 = tslib_1.__importDefault(require("./useForm"));
function propagate(prop, schema, state, fallback) {
    var schemaDisabled = schema === false || schema === '';
    var schemaValue = typeof schema === 'string' ? schema : schemaDisabled ? '' : fallback;
    var resultValue = typeof prop === 'string'
        ? prop
        : prop === false || (prop === undefined && !state) || schemaDisabled
            ? ''
            : schemaValue;
    return [resultValue, schemaValue];
}
function useField(fieldName, props, options) {
    var _a, _b;
    var context = useForm_1.default();
    var name = joinName_1.default(context.name, fieldName);
    var state = mapValues_1.default(context.state, function (prev, key) {
        var next = props[key];
        return next === null || next === undefined ? prev : !!next;
    });
    var changed = !!get_1.default(context.changedMap, name);
    var error = context.schema.getError(name, context.error);
    var errorMessage = context.schema.getErrorMessage(name, context.error);
    var field = context.schema.getField(name);
    var fieldType = context.schema.getType(name);
    var fields = context.schema.getSubfields(name);
    var schemaProps = context.schema.getProps(name, tslib_1.__assign(tslib_1.__assign({}, state), props));
    var _c = propagate(props.label, schemaProps.label, state.label, ''), label = _c[0], labelFallback = _c[1];
    var placeholder = propagate(props.placeholder, schemaProps.placeholder, state.placeholder, label || labelFallback)[0];
    var id = react_1.useMemo(function () { return context.randomId(); }, []);
    var onChange = react_1.useCallback(function (value, key) {
        if (key === void 0) { key = name; }
        context.onChange(key, value);
    }, [context.onChange, name]);
    var value = (_a = props.value) !== null && _a !== void 0 ? _a : get_1.default(context.model, name);
    if ((options === null || options === void 0 ? void 0 : options.initialValue) !== false) {
        var initialValue_1;
        if (((_b = schemaProps.required) !== null && _b !== void 0 ? _b : props.required) && value === undefined) {
            value = context.schema.getInitialValue(name, props);
            initialValue_1 = value;
        }
        else if (props.value !== undefined && props.value !== value) {
            initialValue_1 = props.value;
        }
        react_1.useEffect(function () {
            if (initialValue_1 !== undefined)
                onChange(initialValue_1);
        }, []);
    }
    var fieldProps = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ id: id }, state), { changed: changed,
        error: error,
        errorMessage: errorMessage,
        field: field,
        fieldType: fieldType,
        fields: fields,
        onChange: onChange,
        value: value }), schemaProps), props), { label: label,
        name: name,
        placeholder: placeholder });
    return [fieldProps, context];
}
exports.default = useField;
