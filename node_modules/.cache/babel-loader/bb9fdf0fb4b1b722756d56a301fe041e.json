{"ast":null,"code":"import { __rest } from \"tslib\";\nimport cloneDeep from 'lodash/cloneDeep';\nimport get from 'lodash/get';\nimport invariant from 'invariant';\nimport lowerCase from 'lodash/lowerCase';\nimport omit from 'lodash/omit';\nimport upperFirst from 'lodash/upperFirst';\nimport { Bridge, joinName } from 'uniforms';\n\nconst resolveRef = (referance, schema) => {\n  invariant(referance.startsWith('#'), 'Reference is not an internal reference, and only such are allowed: \"%s\"', referance);\n  const resolvedReference = referance.split('/').filter(part => part && part !== '#').reduce((definition, next) => definition[next], schema);\n  invariant(resolvedReference, 'Reference not found in schema: \"%s\"', referance);\n  return resolvedReference;\n};\n\nconst distinctSchema = schema => {\n  if (schema.type === 'object') {\n    return schema;\n  }\n\n  if (schema.$ref) {\n    return Object.assign(Object.assign({}, schema), resolveRef(schema.$ref, schema));\n  }\n\n  return schema;\n};\n\nconst extractValue = (...xs) => xs.reduce((x, y) => x === false || x === null ? '' : x !== true && x !== undefined ? x : y);\n\nconst pathToName = path => {\n  if (path[0] === '.') path = path.replace(/\\['(.+?)'\\]/g, '.$1').replace(/\\[(.+?)\\]/g, '.$1').replace(/\\\\'/g, \"'\");else path = path.replace(/\\//g, '.').replace(/~0/g, '~').replace(/~1/g, '/');\n  return path.slice(1);\n};\n\nconst toHumanLabel = label => upperFirst(lowerCase(label));\n\nexport default class JSONSchemaBridge extends Bridge {\n  constructor(schema, validator) {\n    super();\n    this.schema = distinctSchema(schema);\n    this._compiledSchema = {};\n    this.validator = validator;\n  }\n\n  static check() {\n    return false;\n  }\n\n  getError(name, error) {\n    const nameParts = joinName(null, name);\n    const rootName = joinName(nameParts.slice(0, -1));\n    const baseName = nameParts[nameParts.length - 1];\n    return error && error.details && error.details.find && error.details.find(detail => {\n      const path = pathToName(detail.dataPath);\n      return name === path || rootName === path && baseName === detail.params.missingProperty;\n    });\n  }\n\n  getErrorMessage(name, error) {\n    const scopedError = this.getError(name, error) || {};\n    return scopedError && scopedError.message || '';\n  }\n\n  getErrorMessages(error) {\n    if (error) {\n      if (Array.isArray(error.details)) {\n        return error.details.reduce((acc, {\n          message\n        }) => acc.concat(message), []);\n      }\n\n      return [error.message || error];\n    }\n\n    return [];\n  }\n\n  getField(name) {\n    return joinName(null, name).reduce((definition, next, nextIndex, array) => {\n      const previous = joinName(array.slice(0, nextIndex));\n      const isRequired = (definition.required || (this._compiledSchema[previous] || {}).required || []).includes(next);\n\n      const _key = joinName(previous, next);\n\n      const _definition = this._compiledSchema[_key] || {};\n\n      if (next === '$' || next === '' + parseInt(next, 10)) {\n        invariant(definition.type === 'array', 'Field not found in schema: \"%s\"', name);\n        definition = Array.isArray(definition.items) ? definition.items[parseInt(next, 10)] : definition.items;\n      } else if (definition.type === 'object') {\n        invariant(definition.properties, 'Field properties not found in schema: \"%s\"', name);\n        definition = definition.properties[next];\n      } else {\n        const [{\n          properties: combinedDefinition = {}\n        } = {}] = ['allOf', 'anyOf', 'oneOf'].filter(key => definition[key]).map(key => definition[key].find(({\n          properties = {}\n        }) => properties[next]));\n        definition = combinedDefinition[next];\n      }\n\n      invariant(definition, 'Field not found in schema: \"%s\"', name);\n\n      if (definition.$ref) {\n        definition = resolveRef(definition.$ref, this.schema);\n      }\n\n      ['allOf', 'anyOf', 'oneOf'].filter(key => definition[key]).forEach(key => {\n        _definition[key] = definition[key].map(def => def.$ref ? resolveRef(def.$ref, this.schema) : def);\n      }); // Naive computation of combined type, properties and required\n\n      if (['allOf', 'anyOf', 'oneOf'].filter(key => definition[key]).length) {\n        _definition.type = ([].concat(_definition.allOf, _definition.anyOf, _definition.oneOf).filter(def => def).find(def => def.type) || {}).type;\n        const [properties, required] = [].concat(_definition.allOf, _definition.anyOf, _definition.oneOf).filter(def => def).reduce(([_properties, _required], {\n          properties,\n          required\n        }) => [Object.assign(_properties, properties), _required.concat(required)], [{}, []]);\n        _definition.properties = properties;\n        _definition.required = required;\n      }\n\n      this._compiledSchema[_key] = Object.assign(_definition, {\n        isRequired\n      });\n      return definition;\n    }, this.schema);\n  }\n\n  getInitialValue(name, props = {}) {\n    const {\n      default: _default,\n      type: _type\n    } = this.getField(name);\n    const {\n      default: defaultValue = _default !== undefined ? _default : get(this.schema.default, name),\n      type = _type\n    } = this._compiledSchema[name];\n    if (defaultValue !== undefined) return cloneDeep(defaultValue);\n\n    if (type === 'array') {\n      const item = this.getInitialValue(joinName(name, '0'));\n      const items = props.initialCount || 0;\n      return Array(items).fill(item);\n    }\n\n    if (type === 'object') return {};\n    return undefined;\n  }\n\n  getProps(name, props = {}) {\n    const _a = this.getField(name),\n          {\n      uniforms\n    } = _a,\n          field = __rest(_a, [\"uniforms\"]);\n\n    const _b = omit(Object.assign(Object.assign(Object.assign({}, field), uniforms), this._compiledSchema[name]), ['default', 'format', 'type']),\n          {\n      enum: enum_,\n      isRequired,\n      title\n    } = _b,\n          ready = __rest(_b, [\"enum\", \"isRequired\", \"title\"]);\n\n    if (enum_) ready.allowedValues = enum_;\n    if (field.type === 'number') ready.decimal = true;\n    if (uniforms && uniforms.type !== undefined) ready.type = uniforms.type;\n    if (ready.required === undefined) ready.required = isRequired;\n    ready.label = extractValue(ready.label, title, toHumanLabel(joinName(null, name).slice(-1)[0]));\n    const options = props.options || ready.options;\n\n    if (options) {\n      if (!Array.isArray(options)) {\n        ready.transform = value => options[value];\n\n        ready.allowedValues = Object.keys(options);\n      } else {\n        ready.transform = value => options.find(option => option.value === value).label;\n\n        ready.allowedValues = options.map(option => option.value);\n      }\n    }\n\n    return ready;\n  }\n\n  getSubfields(name) {\n    if (!name) {\n      if (this.schema.properties) {\n        return Object.keys(this.schema.properties);\n      }\n\n      return [];\n    }\n\n    const {\n      type: _type,\n      properties: _properties\n    } = this.getField(name);\n    const {\n      type: fieldType = _type,\n      properties: fieldProperties = _properties\n    } = this._compiledSchema[name];\n\n    if (fieldType === 'object') {\n      return Object.keys(fieldProperties);\n    }\n\n    return [];\n  }\n\n  getType(name) {\n    const {\n      type: _type,\n      format: fieldFormat\n    } = this.getField(name);\n    const {\n      type: fieldType = _type\n    } = this._compiledSchema[name];\n    if (fieldFormat === 'date-time') return Date;\n    if (fieldType === 'string') return String;\n    if (fieldType === 'number') return Number;\n    if (fieldType === 'integer') return Number;\n    if (fieldType === 'object') return Object;\n    if (fieldType === 'array') return Array;\n    if (fieldType === 'boolean') return Boolean;\n    invariant(fieldType !== 'null', 'Field \"%s\" can not be represented as a type null', name);\n    return fieldType;\n  }\n\n  getValidator() {\n    return this.validator;\n  }\n\n}","map":{"version":3,"sources":["/Users/rjgleave/mysrc/oneq-work/sa-form/node_modules/uniforms-bridge-json-schema/es6/JSONSchemaBridge.js"],"names":["__rest","cloneDeep","get","invariant","lowerCase","omit","upperFirst","Bridge","joinName","resolveRef","referance","schema","startsWith","resolvedReference","split","filter","part","reduce","definition","next","distinctSchema","type","$ref","Object","assign","extractValue","xs","x","y","undefined","pathToName","path","replace","slice","toHumanLabel","label","JSONSchemaBridge","constructor","validator","_compiledSchema","check","getError","name","error","nameParts","rootName","baseName","length","details","find","detail","dataPath","params","missingProperty","getErrorMessage","scopedError","message","getErrorMessages","Array","isArray","acc","concat","getField","nextIndex","array","previous","isRequired","required","includes","_key","_definition","parseInt","items","properties","combinedDefinition","key","map","forEach","def","allOf","anyOf","oneOf","_properties","_required","getInitialValue","props","default","_default","_type","defaultValue","item","initialCount","fill","getProps","_a","uniforms","field","_b","enum","enum_","title","ready","allowedValues","decimal","options","transform","value","keys","option","getSubfields","fieldType","fieldProperties","getType","format","fieldFormat","Date","String","Number","Boolean","getValidator"],"mappings":"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","sourcesContent":["import { __rest } from \"tslib\";\nimport cloneDeep from 'lodash/cloneDeep';\nimport get from 'lodash/get';\nimport invariant from 'invariant';\nimport lowerCase from 'lodash/lowerCase';\nimport omit from 'lodash/omit';\nimport upperFirst from 'lodash/upperFirst';\nimport { Bridge, joinName } from 'uniforms';\nconst resolveRef = (referance, schema) => {\n    invariant(referance.startsWith('#'), 'Reference is not an internal reference, and only such are allowed: \"%s\"', referance);\n    const resolvedReference = referance\n        .split('/')\n        .filter(part => part && part !== '#')\n        .reduce((definition, next) => definition[next], schema);\n    invariant(resolvedReference, 'Reference not found in schema: \"%s\"', referance);\n    return resolvedReference;\n};\nconst distinctSchema = schema => {\n    if (schema.type === 'object') {\n        return schema;\n    }\n    if (schema.$ref) {\n        return Object.assign(Object.assign({}, schema), resolveRef(schema.$ref, schema));\n    }\n    return schema;\n};\nconst extractValue = (...xs) => xs.reduce((x, y) => x === false || x === null ? '' : x !== true && x !== undefined ? x : y);\nconst pathToName = path => {\n    if (path[0] === '.')\n        path = path\n            .replace(/\\['(.+?)'\\]/g, '.$1')\n            .replace(/\\[(.+?)\\]/g, '.$1')\n            .replace(/\\\\'/g, \"'\");\n    else\n        path = path\n            .replace(/\\//g, '.')\n            .replace(/~0/g, '~')\n            .replace(/~1/g, '/');\n    return path.slice(1);\n};\nconst toHumanLabel = label => upperFirst(lowerCase(label));\nexport default class JSONSchemaBridge extends Bridge {\n    constructor(schema, validator) {\n        super();\n        this.schema = distinctSchema(schema);\n        this._compiledSchema = {};\n        this.validator = validator;\n    }\n    static check() {\n        return false;\n    }\n    getError(name, error) {\n        const nameParts = joinName(null, name);\n        const rootName = joinName(nameParts.slice(0, -1));\n        const baseName = nameParts[nameParts.length - 1];\n        return (error &&\n            error.details &&\n            error.details.find &&\n            error.details.find(detail => {\n                const path = pathToName(detail.dataPath);\n                return (name === path ||\n                    (rootName === path && baseName === detail.params.missingProperty));\n            }));\n    }\n    getErrorMessage(name, error) {\n        const scopedError = this.getError(name, error) || {};\n        return (scopedError && scopedError.message) || '';\n    }\n    getErrorMessages(error) {\n        if (error) {\n            if (Array.isArray(error.details)) {\n                return error.details.reduce((acc, { message }) => acc.concat(message), []);\n            }\n            return [error.message || error];\n        }\n        return [];\n    }\n    getField(name) {\n        return joinName(null, name).reduce((definition, next, nextIndex, array) => {\n            const previous = joinName(array.slice(0, nextIndex));\n            const isRequired = (definition.required ||\n                (this._compiledSchema[previous] || {}).required ||\n                []).includes(next);\n            const _key = joinName(previous, next);\n            const _definition = this._compiledSchema[_key] || {};\n            if (next === '$' || next === '' + parseInt(next, 10)) {\n                invariant(definition.type === 'array', 'Field not found in schema: \"%s\"', name);\n                definition = Array.isArray(definition.items)\n                    ? definition.items[parseInt(next, 10)]\n                    : definition.items;\n            }\n            else if (definition.type === 'object') {\n                invariant(definition.properties, 'Field properties not found in schema: \"%s\"', name);\n                definition = definition.properties[next];\n            }\n            else {\n                const [{ properties: combinedDefinition = {} } = {}] = [\n                    'allOf',\n                    'anyOf',\n                    'oneOf',\n                ]\n                    .filter(key => definition[key])\n                    .map(key => definition[key].find(({ properties = {} }) => properties[next]));\n                definition = combinedDefinition[next];\n            }\n            invariant(definition, 'Field not found in schema: \"%s\"', name);\n            if (definition.$ref) {\n                definition = resolveRef(definition.$ref, this.schema);\n            }\n            ['allOf', 'anyOf', 'oneOf']\n                .filter(key => definition[key])\n                .forEach(key => {\n                _definition[key] = definition[key].map(def => def.$ref ? resolveRef(def.$ref, this.schema) : def);\n            });\n            // Naive computation of combined type, properties and required\n            if (['allOf', 'anyOf', 'oneOf'].filter(key => definition[key]).length) {\n                _definition.type = ([]\n                    .concat(_definition.allOf, _definition.anyOf, _definition.oneOf)\n                    .filter((def) => def)\n                    .find((def) => def.type) || {}).type;\n                const [properties, required] = []\n                    .concat(_definition.allOf, _definition.anyOf, _definition.oneOf)\n                    .filter(def => def)\n                    .reduce(([_properties, _required], { properties, required }) => [\n                    Object.assign(_properties, properties),\n                    _required.concat(required),\n                ], [{}, []]);\n                _definition.properties = properties;\n                _definition.required = required;\n            }\n            this._compiledSchema[_key] = Object.assign(_definition, { isRequired });\n            return definition;\n        }, this.schema);\n    }\n    getInitialValue(name, props = {}) {\n        const { default: _default, type: _type } = this.getField(name);\n        const { default: defaultValue = _default !== undefined\n            ? _default\n            : get(this.schema.default, name), type = _type, } = this._compiledSchema[name];\n        if (defaultValue !== undefined)\n            return cloneDeep(defaultValue);\n        if (type === 'array') {\n            const item = this.getInitialValue(joinName(name, '0'));\n            const items = props.initialCount || 0;\n            return Array(items).fill(item);\n        }\n        if (type === 'object')\n            return {};\n        return undefined;\n    }\n    getProps(name, props = {}) {\n        const _a = this.getField(name), { uniforms } = _a, field = __rest(_a, [\"uniforms\"]);\n        const _b = omit(Object.assign(Object.assign(Object.assign({}, field), uniforms), this._compiledSchema[name]), ['default', 'format', 'type']), { enum: enum_, isRequired, title } = _b, ready = __rest(_b, [\"enum\", \"isRequired\", \"title\"]);\n        if (enum_)\n            ready.allowedValues = enum_;\n        if (field.type === 'number')\n            ready.decimal = true;\n        if (uniforms && uniforms.type !== undefined)\n            ready.type = uniforms.type;\n        if (ready.required === undefined)\n            ready.required = isRequired;\n        ready.label = extractValue(ready.label, title, toHumanLabel(joinName(null, name).slice(-1)[0]));\n        const options = props.options || ready.options;\n        if (options) {\n            if (!Array.isArray(options)) {\n                ready.transform = value => options[value];\n                ready.allowedValues = Object.keys(options);\n            }\n            else {\n                ready.transform = value => options.find(option => option.value === value).label;\n                ready.allowedValues = options.map(option => option.value);\n            }\n        }\n        return ready;\n    }\n    getSubfields(name) {\n        if (!name) {\n            if (this.schema.properties) {\n                return Object.keys(this.schema.properties);\n            }\n            return [];\n        }\n        const { type: _type, properties: _properties } = this.getField(name);\n        const { type: fieldType = _type, properties: fieldProperties = _properties, } = this._compiledSchema[name];\n        if (fieldType === 'object') {\n            return Object.keys(fieldProperties);\n        }\n        return [];\n    }\n    getType(name) {\n        const { type: _type, format: fieldFormat } = this.getField(name);\n        const { type: fieldType = _type } = this._compiledSchema[name];\n        if (fieldFormat === 'date-time')\n            return Date;\n        if (fieldType === 'string')\n            return String;\n        if (fieldType === 'number')\n            return Number;\n        if (fieldType === 'integer')\n            return Number;\n        if (fieldType === 'object')\n            return Object;\n        if (fieldType === 'array')\n            return Array;\n        if (fieldType === 'boolean')\n            return Boolean;\n        invariant(fieldType !== 'null', 'Field \"%s\" can not be represented as a type null', name);\n        return fieldType;\n    }\n    getValidator() {\n        return this.validator;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}